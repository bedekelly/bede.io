<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Bede Kelly - bede kelly]]></title><description><![CDATA[probably something about programming.]]></description><link>http://mains.120v.ac/</link><generator>Ghost 0.5</generator><lastBuildDate>Sun, 25 Jan 2015 16:47:08 GMT</lastBuildDate><atom:link href="http://mains.120v.ac/author/bede/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Thoughts on Interactive Fiction]]></title><description><![CDATA[<p>It's no great secret that interactive fiction worlds like that of Zork tend to be pretty limited in scope, both in terms of narrative and in terms of the user's breadth of options. It's unclear at this point whether this is because of the difficulties of language comprehension, the difficulties of adding new features after the fact, or some other reason, but I'm determined to make the interactions that a player has with the world as varied as possible. </p>

<p>The most difficult task I can forsee is implementing NPCs - should they be represented as simple state machines, or more complex objects with levels of contentment, fear etc.? How should an interaction lasting multiple 'turns' be processed, like for example a conversation? It seems like the easiest option would be to implement some kind of "conversation" state, where if the player tries to perform an action outside of responding with a known set of possible responses, the server will inform the player that they are <code>Still in a conversation with $NPC_name!</code>. It'd make it a lot easier, but wouldn't allow for anything like <code>Show the barman my sword</code> without special-casing for each encounter.</p>

<p>At a more abstract level, the philosophy for this game will be to provide as open and accessible a world as possible - this is something of a contrast to Zork, where the object of the game seems to be on the whole centred around revealing the core narrative. There won't be a fixed 'Main Quest'; however, players may choose to undertake some of a huge number of available quests. There will probably be some kind of 'Quest Log', which will implement the functionality to let players run between quests whenever they like. It'll also store the 'timer' information, to allow for quests with expiry dates, and allow callbacks to be run when either the quest is fulfilled or the time limit expires.</p>

<p>As one of the most vital features for this game's success is its extendability, it will be thoroughly put through its paces with any number of items which special-case absolutely everything. Rings of increased inventory space, boots of quicker walking and rods of teleportation will abound, as well as - one hopes - more inventive names.</p>

<p>There won't be any kind of hotbar, or inventory/character separation - the game will assume that everything you're carrying is accessible to you in a negligible amount of time. There may be some form of bank or deposit box, in which you can deposit your gold and treasures to keep them safe.</p>

<p>Most of all, though? It has to be damn immersive. Fun, sure -  but it's damn well got to grip whoever's playing it by the sheer number of possibilities. Otherwise... it needs more work.</p>]]></description><link>http://mains.120v.ac/2015/01/23/thoughts-on-interactive-fiction/</link><guid isPermaLink="false">c4a66569-4e2a-4d21-abbc-17e580358e30</guid><dc:creator><![CDATA[Bede Kelly]]></dc:creator><pubDate>Fri, 23 Jan 2015 23:48:56 GMT</pubDate></item><item><title><![CDATA[Analysis Section]]></title><description><![CDATA[<h2 id="researchmethods">Research Methods</h2>

<p>To better understand the current problems facing those downloading multiple repositories from a user's Github account, I will observe a frequent user of Git and Github clone multiple repositories from a remote user. Our remote user, <a href="https://github.com/simon-weber?tab=repositories">simon-weber</a> has at the time of writing exactly 40 repositories. Our test user has been instructed to download the 'muspy', 'gomegle', 'crunchbang-conf' and 'omegle-to-irc' repositories.</p>

<p><img src="http://mains.120v.ac/content/images/2015/01/Screenshot-from-2015-01-25-15-33-02.png" alt="Simon Weber's Github Page"></p>

<p>Below is a screenshot showing the test user's attempts to clone these repositories. Note the spelling mistake made in cloning 'crunchbang-conf', leading to an error that the test user must use a keyboard interrupt to escape from, and the amount of characters necessary to type out these commands.</p>

<p><img src="http://mains.120v.ac/content/images/2015/01/git_woes.png" alt="Screenshot showing a long, failed trail of Git commands, ending in Control-C to exit the program"></p>

<p>This observation highlighted some key flaws in the way that multiple Github repositories must be cloned:</p>

<ul>
<li><p>Every repository requires its own command to clone. Our test user circumvented this by using the Bash syntax to instruct the shell to run multiple commands sequentially, but this means extremely long lines of code.</p></li>
<li><p>Every repository's URL must be found and copied into the terminal, whether by hand or by using system functions (e.g. middle-click on Unix systems). While the copying may not be overly time-consuming for a small number of repositories, for a larger number it will get increasingly frustrating for the user (in fact, the user did report a sense of annoyance at having to perform such a menial action just 4 times).</p></li>
<li><p>The output is completely opaque to any non-expert user. The version control system Git is renowned for being difficult to use: see <a href="http://merrigrove.blogspot.co.uk/2014/02/why-heck-is-git-so-hard-places-model-ok.html">here</a> and <a href="http://stevebennett.me/2012/02/24/10-things-i-hate-about-git/">here</a> (warning: strong language) for examples of user frustration and confusion.</p></li>
</ul>

<hr>

<p>My project, then, should aim to provide a clear, simple method of cloning single or multiple repositories from a single Github user's account.</p>

<p>In order to gain a more clear idea of the required solution, I decided to undertake an interview with Daniel: the client for this project, and another regular user of Github. I wanted to focus on the interface that would be easiest to use, while also being the most accessible for the most people.</p>

<p>The transcript of the interview is given below, with no modifications save the elimination of pauses.</p>

<pre><code>Me: So, what's the most important thing you want to see in this project? Do you want something that looks pretty; something that 'just works'?

Dan: I think the most important thing is flexibility. It's alright if it works for me; I can deal with the command line syntax or whatever. But it'd be great if there was some kind of menu as well, rather than having to type everything out.

Me: I understand, so should there be more than one possible interface?

Dan: Yeah, I guess that could work. I mean, sometimes you're just going to want to run a single command and have it run in the background, and sometimes you're gonna want to inspect each one, maybe look at its description, before you decide whether you want to clone it or not.

Me: I'm thinking about using the Curses framework to design menus for this project, you know, with buttons labelled clone, skip and so on. Can you see any problems with that?

Dan: Well, I don't know, I haven't had great results with Curses on Windows, so that might be worth considering.

Me: Yeah, I think there's a few problems with terminal control, the command prompt is pretty outdated - so should there just be a text-based version as well, that doesn't need terminal control like that?

Dan: That could work, yeah. Just on the subject of being easy to use, would this project show the original Git errors if any get thrown? Sometimes I'd like to see those, or at least see what type of error it was.

Me: Yeah, that could be integrated for sure - the original errors should get logged in a standard form, and there'll be a slightly nicer error message on screen for the non-experts. So, we've got two interfaces, and both of them need some way of checking which repositories the user actually wants -- unless they just want to download everything?

Dan: Can we do that? I mean, I don't just want to go through every repository clicking "Yes, yes, yes"-

Me: Sure, I'll add an option just to download everything. Anything else you'd like to see? You'll be running this on Unix-like systems, right?

Dan: Yeah, Mac OSX and maybe Mint, so it should probably work on both of those. I'll be using this a lot though, so there'd better not be any bugs!

Me: I'll do my best - thanks a lot for your time.  
</code></pre>

<p>The interview confirmed what I thought: the major barrier between developers and their goal of cloning multiple Github repositories is usability.</p>

<h3 id="backgroundtotheproblem">Background to the Problem</h3>

<p>Many developers find the need in their daily lives to clone multiple repositories belonging to a single user. This is often as a result of projects being split into different repositories for easier version-control and separation of concerns (e.g. the front-end and back-end systems of a project).</p>

<p>However, the current available methods are both unwieldy and unfriendly to users, requiring either lots of time-consuming copy-pasting into a terminal with the same repeated command, or an in-depth knowledge of technology such as Bash variable expansion.</p>

<p>My system will be much faster and, more accessible and above all more user-friendly. Instead of accumulating a two-hundred-character command in Bash with full Git URLs, my project will provide both a menu-based and a vastly simplified command-line-based interface to download some or all of a user's Github repositories. </p>

<h3 id="currentsystem">Current System</h3>

<p>The current system for downloading multiple repositories from a user's Github account is, largely, non-existent. The most common system is, essentially, just to 'git clone $URL' for each repository that the user wants to download. For small numbers of repositories, perhaps 2 or 3, this may be sufficient; however, this is an extremely time-consuming way of achieving what is essentially a very simple task. The test user, Alexa, commented that it took 'ages' to find and download just 4, and when asked about the output she informed me that she did not understand most of what it meant.</p>

<p>Below is a screenshot of a rather cryptic error caused by differences between the remote repository and the local version, when a simple <code>git pull</code> is run inside a repository.</p>

<p><img src="http://mains.120v.ac/content/images/2015/01/Screenshot-from-2015-01-23-04-01-22.png" alt="Screenshot"></p>

<h3 id="identificationofprospectiveusers">Identification of Prospective Users</h3>

<p>Users of this program will, like Daniel, be somewhat experienced with the basics of Git and Github. However, they may not have read enough of Git's documentation to fully understand the error messages they may recieve (see above for an example). This, potentially, means that there is a very large client base for this system, who want to interact with their repositories and the repositories of others in a more friendly and interactive way.</p>

<p>More advanced users could use the command-line interface to achieve all that they want in a single <em>readable</em> line of code, whereas newer users could use the menu interface to iterate through each repository and view their descriptions before deciding whether to clone them or not. This interface will use the arrow keys and return key to select choices, making it essentially universal to users of any major operating system. The skills to use this system at its most basic level will be absolutely negligible, and far below the expected skill level of anyone who requires the use of a Github repository.</p>

<p>The userbase will be largely comprised of developers, so I anticipate more heavy usage of the command-line interface than the Curses interface, as this will easily integrate into any of their own custom shell-scripts for maintaining repositories. In either case, the userbase will certainly be comfortable with one or both of the provided interfaces.</p>

<h3 id="identificationofuserneedsandacceptablelimitations">Identification of User Needs and Acceptable Limitations</h3>

<p>My research has found that the most common barriers to using Git and Github effectively lie in the realm of usability and comprehension: the system, in short, needs to be easier to use for newer developers, and faster to use for those more experienced with version control using these technologies. </p>

<p>As a result of this, my client would like me to build a system that:</p>

<ul>
<li>Provides an easy-to-use and convenient mechanism to download and/or update multiple Github repositories at once</li>
<li>Provides a faster alternative to manually downloading each repository through finding its URL through the web interface</li>
<li>Allows automation with commands to "download all", "update all current and don't download any new repositories" etc.</li>
<li>Provides user-comprehensible error messages to inform the user more succinctly and clearly what the problem is</li>
</ul>

<p>The system will not, as a result of inspection of the Github API for returning JSON information about a user's repositories, detect (and hence be able to download/update) more than the first 100 repositories. From my research, however, the average number of repositories per user lies far below that, typically in the region between 5 and 15.</p>

<p>The system will not be able to <em>push</em> repositories as well as <em>pulling</em> them. This is not as a result of difficulty (since the command is a simple <code>git push</code> on any system with the <code>git</code> program installed), but it is simply out of the project's scope. To push repositories would require authentication with the remote repository, whereas a 'pull' is permitted for any public repository - it will work in precisely the same way for any public repository as it will for the user's own repositories.</p>

<p>The system will not implement any failsafes for sudden loss of power or system shutdowns. This would introduce another arbitrary layer of complexity which would only be relied upon in these (extremely rare) situations, and quite possibly a performance penalty. As well as this, even if a repository's cloning were halted halfway through, re-running the program would fix the issue without errors (as does a simple 'git pull'). This feature has also not been requested, and after consulting with the client does not seem to be an issue of any priority.</p>

<h3 id="datasourcesanddestinations">Data Sources and Destinations</h3>

<table>  
    <tr>
        <th>Description</th>
        <th>Source</th>
        <th>Destination</th>
    </tr>

    <tr>
        <td>Remote User's JSON information (as UTF-8 string)</td>
        <td>Github API <a href="http://mains.120v.ac/api.github.com">here</a></td>
        <td>Local Python object as per Python 'json.loads' docs: json_data</td>
    </tr>

    <tr>
        <td>Remote user's requested repositories (presumably as octet stream, but the implementation is hidden)</td>
        <td>Github Servers, through 'git clone'</td>
        <td>User's local filesystem (in the current working directory)</td>
    </tr>

    <tr>
        <td>Options for the program's behaviour</td>
        <td>Command-line options (through parse_args())and menu choices</td>
        <td>'arguments' dictionary, to be read by main()</td>
    </tr>

    <tr>
        <td>Remote User's API URL</td>
        <td>Remote user's username, passed into the api_url string-formatting function</td>
        <td>Local URL string, passed into 'get_json' and used for urllib.request.urlopen </td>
    </tr>

</table>]]></description><link>http://mains.120v.ac/2015/01/23/analysis-section/</link><guid isPermaLink="false">80c74f21-0126-466b-be8e-0ebc92499c9d</guid><dc:creator><![CDATA[Bede Kelly]]></dc:creator><pubDate>Fri, 23 Jan 2015 03:15:32 GMT</pubDate></item><item><title><![CDATA[Thoughts on Interactive Fiction Programming]]></title><description><![CDATA[<p>After reading Ready Player One, I'm hyped for open-world gaming. Stories, interactions, quests, worlds, planets, all of that good stuff. I think I'll make one for myself.</p>

<p>I don't care much about the interface; to me, the permissive nature of the game's world is the important thing. I want it to be as easy as possible to expand: patch in new items, vehicles, quests, you name it.</p>

<p>My idea, eventually, is to write something like an interactive text fiction game: check out <a href="http://www.web-adventures.org/cgi-bin/webfrotz?s=Zork1&amp;t=Y">Zork</a> if you haven't seen this kind of thing before, it's way cool. </p>

<p>So, what better place to start than...</p>

<h3 id="languagechoice">Language Choice</h3>

<p>One of the first things I decided upon straight away when thinking about this project was that I want to build as much as possible from scratch. Especially since the interface is going to be so comparatively easy to write, I want  something that's going to be a real project to get my teeth into. That means writing parsers and lexers from scratch, and quite possibly writing my own console-like interface with a terminal control library to get it <em>just right</em>. And, as regards language choice, it means I won't be using anything like dedicated interactive fiction languages. I'm sure they work very well at what they do, but it'll be a much more rewarding and - hopefully - fun exercise to write the implementation code myself.</p>

<p>I briefly considered C for this project, as I'm currently learning it at a basic level (and NCurses is a native C library). But thinking about implementing a parser in C makes me cringe - I'd much rather have the abstraction of Python when it comes to operations like stripping the spaces out of strings.</p>

<p>Python seems like as good a choice as any. It's got a decent regular expression library (at least, for our purposes), lots of built-in string methods like <code>str.strip</code>, and a very easy-to-navigate system of objects and namespaces. As well as this, it's got a well-documented module of bindings for libncurses, and I've got some boilerplate code sitting around already for relatively pain-free terminal control (context-manager decorators for setting up a stdscr with curses etc.). </p>

<p>Python also has the advantage of its interactive prompt (i.e. a read-eval-print-loop). This will undoubtedly be invaluable when it comes to testing code on-the-fly: I can't even imagine recompiling every time I want to test some code in, say, C++.</p>

<h3 id="interface">Interface</h3>

<p>The interface is absolutely not the focus of the project, so I won't spend any more time than necessary on getting a working prototype; I can always polish it up (add colours, etc.) after the language processing is in a working state. It will have two main components:</p>

<ul>
<li>The input box - a standard editable text box for the user's input; and</li>
<li>The output box - a scrolling display for the displayed output.</li>
</ul>

<h3 id="implementation">Implementation</h3>

<p>I'm hoping to use some kind of client-server model for this game. It's not going to be multiplayer - at least, not in the forseeable future - but it should have some kind of time simulation. This will probably be implemented using threads. The server and client will have two message pipes between them - the server will read/lex/parse/execute the client's messages, and send back messages which the client prints. The server may also be running other threads, which have access to the out-pipe but not the in-pipe, and therefore can send messages to the client (e.g. hunger warnings, environment events). It'll almost definitely have some kind of system for 'ticks', or arbitrary small units of time. The server will hold all of the information about the player in state, and the goal will be to achieve "separation of concerns" (ew) such that multiple save slots will be available, indexed by player name.</p>]]></description><link>http://mains.120v.ac/2015/01/23/interactive-fiction/</link><guid isPermaLink="false">dec841ef-ad5f-4339-aadb-6ee5327ab8c0</guid><category><![CDATA[Fiction]]></category><category><![CDATA[Game]]></category><category><![CDATA[Parsing]]></category><category><![CDATA[NLP]]></category><dc:creator><![CDATA[Bede Kelly]]></dc:creator><pubDate>Fri, 23 Jan 2015 02:31:00 GMT</pubDate></item></channel></rss>